{
  "version": 3,
  "sources": ["../../three/examples/jsm/exporters/ColladaExporter.js"],
  "sourcesContent": ["import {\n\tColor,\n\tDoubleSide,\n\tMatrix4,\n\tMeshBasicMaterial\n} from 'three';\n\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  const exporter = new ColladaExporter();\n *\n *  const data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\n\nclass ColladaExporter {\n\n\tparse( object, onDone, options = {} ) {\n\n\t\toptions = Object.assign( {\n\t\t\tversion: '1.4.1',\n\t\t\tauthor: null,\n\t\t\ttextureDirectory: '',\n\t\t}, options );\n\n\t\tif ( options.textureDirectory !== '' ) {\n\n\t\t\toptions.textureDirectory = `${ options.textureDirectory }/`\n\t\t\t\t.replace( /\\\\/g, '/' )\n\t\t\t\t.replace( /\\/+/g, '/' );\n\n\t\t}\n\n\t\tconst version = options.version;\n\n\t\tif ( version !== '1.4.1' && version !== '1.5.0' ) {\n\n\t\t\tconsole.warn( `ColladaExporter : Version ${ version } not supported for export. Only 1.4.1 and 1.5.0.` );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Convert the urdf xml into a well-formatted, indented format\n\t\tfunction format( urdf ) {\n\n\t\t\tconst IS_END_TAG = /^<\\//;\n\t\t\tconst IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n\t\t\tconst HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n\t\t\tconst pad = ( ch, num ) => ( num > 0 ? ch + pad( ch, num - 1 ) : '' );\n\n\t\t\tlet tagnum = 0;\n\n\t\t\treturn urdf\n\t\t\t\t.match( /(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g )\n\t\t\t\t.map( tag => {\n\n\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\ttagnum --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst res = `${ pad( '  ', tagnum ) }${ tag }`;\n\n\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && ! IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\ttagnum ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} )\n\t\t\t\t.join( '\\n' );\n\n\t\t}\n\n\t\t// Convert an image into a png format for saving\n\t\tfunction base64ToBuffer( str ) {\n\n\t\t\tconst b = atob( str );\n\t\t\tconst buf = new Uint8Array( b.length );\n\n\t\t\tfor ( let i = 0, l = buf.length; i < l; i ++ ) {\n\n\t\t\t\tbuf[ i ] = b.charCodeAt( i );\n\n\t\t\t}\n\n\t\t\treturn buf;\n\n\t\t}\n\n\t\tlet canvas, ctx;\n\n\t\tfunction imageToData( image, ext ) {\n\n\t\t\tcanvas = canvas || document.createElement( 'canvas' );\n\t\t\tctx = ctx || canvas.getContext( '2d' );\n\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\n\t\t\tctx.drawImage( image, 0, 0 );\n\n\t\t\t// Get the base64 encoded data\n\t\t\tconst base64data = canvas\n\t\t\t\t.toDataURL( `image/${ ext }`, 1 )\n\t\t\t\t.replace( /^data:image\\/(png|jpg);base64,/, '' );\n\n\t\t\t// Convert to a uint8 array\n\t\t\treturn base64ToBuffer( base64data );\n\n\t\t}\n\n\t\t// gets the attribute array. Generate a new array if the attribute is interleaved\n\t\tconst getFuncs = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t\tfunction attrBufferToArray( attr ) {\n\n\t\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\t\t// use the typed array constructor to save on memory\n\t\t\t\tconst arr = new attr.array.constructor( attr.count * attr.itemSize );\n\t\t\t\tconst size = attr.itemSize;\n\n\t\t\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < size; j ++ ) {\n\n\t\t\t\t\t\tarr[ i * size + j ] = attr[ getFuncs[ j ] ]( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn arr;\n\n\t\t\t} else {\n\n\t\t\t\treturn attr.array;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Returns an array of the same type starting at the `st` index,\n\t\t// and `ct` length\n\t\tfunction subArray( arr, st, ct ) {\n\n\t\t\tif ( Array.isArray( arr ) ) return arr.slice( st, st + ct );\n\t\t\telse return new arr.constructor( arr.buffer, st * arr.BYTES_PER_ELEMENT, ct );\n\n\t\t}\n\n\t\t// Returns the string for a geometry's attribute\n\t\tfunction getAttribute( attr, name, params, type ) {\n\n\t\t\tconst array = attrBufferToArray( attr );\n\t\t\tconst res =\n\t\t\t\t\t`<source id=\"${ name }\">` +\n\n\t\t\t\t\t`<float_array id=\"${ name }-array\" count=\"${ array.length }\">` +\n\t\t\t\t\tarray.join( ' ' ) +\n\t\t\t\t\t'</float_array>' +\n\n\t\t\t\t\t'<technique_common>' +\n\t\t\t\t\t`<accessor source=\"#${ name }-array\" count=\"${ Math.floor( array.length / attr.itemSize ) }\" stride=\"${ attr.itemSize }\">` +\n\n\t\t\t\t\tparams.map( n => `<param name=\"${ n }\" type=\"${ type }\" />` ).join( '' ) +\n\n\t\t\t\t\t'</accessor>' +\n\t\t\t\t\t'</technique_common>' +\n\t\t\t\t\t'</source>';\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t// Returns the string for a node's transform information\n\t\tlet transMat;\n\t\tfunction getTransform( o ) {\n\n\t\t\t// ensure the object's matrix is up to date\n\t\t\t// before saving the transform\n\t\t\to.updateMatrix();\n\n\t\t\ttransMat = transMat || new Matrix4();\n\t\t\ttransMat.copy( o.matrix );\n\t\t\ttransMat.transpose();\n\t\t\treturn `<matrix>${ transMat.toArray().join( ' ' ) }</matrix>`;\n\n\t\t}\n\n\t\t// Process the given piece of geometry into the geometry library\n\t\t// Returns the mesh id\n\t\tfunction processGeometry( g ) {\n\n\t\t\tlet info = geometryInfo.get( g );\n\n\t\t\tif ( ! info ) {\n\n\t\t\t\t// convert the geometry to bufferGeometry if it isn't already\n\t\t\t\tconst bufferGeometry = g;\n\n\t\t\t\tif ( bufferGeometry.isBufferGeometry !== true ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst meshid = `Mesh${ libraryGeometries.length + 1 }`;\n\n\t\t\t\tconst indexCount =\n\t\t\t\t\tbufferGeometry.index ?\n\t\t\t\t\t\tbufferGeometry.index.count * bufferGeometry.index.itemSize :\n\t\t\t\t\t\tbufferGeometry.attributes.position.count;\n\n\t\t\t\tconst groups =\n\t\t\t\t\tbufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ?\n\t\t\t\t\t\tbufferGeometry.groups :\n\t\t\t\t\t\t[ { start: 0, count: indexCount, materialIndex: 0 } ];\n\n\n\t\t\t\tconst gname = g.name ? ` name=\"${ g.name }\"` : '';\n\t\t\t\tlet gnode = `<geometry id=\"${ meshid }\"${ gname }><mesh>`;\n\n\t\t\t\t// define the geometry node and the vertices for the geometry\n\t\t\t\tconst posName = `${ meshid }-position`;\n\t\t\t\tconst vertName = `${ meshid }-vertices`;\n\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.position, posName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\tgnode += `<vertices id=\"${ vertName }\"><input semantic=\"POSITION\" source=\"#${ posName }\" /></vertices>`;\n\n\t\t\t\t// NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n\t\t\t\t// can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n\t\t\t\t// models with attributes that share an offset.\n\t\t\t\t// MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n\n\t\t\t\t// serialize normals\n\t\t\t\tlet triangleInputs = `<input semantic=\"VERTEX\" source=\"#${ vertName }\" offset=\"0\" />`;\n\t\t\t\tif ( 'normal' in bufferGeometry.attributes ) {\n\n\t\t\t\t\tconst normName = `${ meshid }-normal`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.normal, normName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"NORMAL\" source=\"#${ normName }\" offset=\"0\" />`;\n\n\t\t\t\t}\n\n\t\t\t\t// serialize uvs\n\t\t\t\tif ( 'uv' in bufferGeometry.attributes ) {\n\n\t\t\t\t\tconst uvName = `${ meshid }-texcoord`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.uv, uvName, [ 'S', 'T' ], 'float' );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${ uvName }\" offset=\"0\" set=\"0\" />`;\n\n\t\t\t\t}\n\n\t\t\t\t// serialize lightmap uvs\n\t\t\t\tif ( 'uv2' in bufferGeometry.attributes ) {\n\n\t\t\t\t\tconst uvName = `${ meshid }-texcoord2`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.uv2, uvName, [ 'S', 'T' ], 'float' );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${ uvName }\" offset=\"0\" set=\"1\" />`;\n\n\t\t\t\t}\n\n\t\t\t\t// serialize colors\n\t\t\t\tif ( 'color' in bufferGeometry.attributes ) {\n\n\t\t\t\t\tconst colName = `${ meshid }-color`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.color, colName, [ 'X', 'Y', 'Z' ], 'uint8' );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"COLOR\" source=\"#${ colName }\" offset=\"0\" />`;\n\n\t\t\t\t}\n\n\t\t\t\tlet indexArray = null;\n\t\t\t\tif ( bufferGeometry.index ) {\n\n\t\t\t\t\tindexArray = attrBufferToArray( bufferGeometry.index );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArray = new Array( indexCount );\n\t\t\t\t\tfor ( let i = 0, l = indexArray.length; i < l; i ++ ) indexArray[ i ] = i;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst subarr = subArray( indexArray, group.start, group.count );\n\t\t\t\t\tconst polycount = subarr.length / 3;\n\t\t\t\t\tgnode += `<triangles material=\"MESH_MATERIAL_${ group.materialIndex }\" count=\"${ polycount }\">`;\n\t\t\t\t\tgnode += triangleInputs;\n\n\t\t\t\t\tgnode += `<p>${ subarr.join( ' ' ) }</p>`;\n\t\t\t\t\tgnode += '</triangles>';\n\n\t\t\t\t}\n\n\t\t\t\tgnode += '</mesh></geometry>';\n\n\t\t\t\tlibraryGeometries.push( gnode );\n\n\t\t\t\tinfo = { meshid: meshid, bufferGeometry: bufferGeometry };\n\t\t\t\tgeometryInfo.set( g, info );\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t}\n\n\t\t// Process the given texture into the image library\n\t\t// Returns the image library\n\t\tfunction processTexture( tex ) {\n\n\t\t\tlet texid = imageMap.get( tex );\n\t\t\tif ( texid == null ) {\n\n\t\t\t\ttexid = `image-${ libraryImages.length + 1 }`;\n\n\t\t\t\tconst ext = 'png';\n\t\t\t\tconst name = tex.name || texid;\n\t\t\t\tlet imageNode = `<image id=\"${ texid }\" name=\"${ name }\">`;\n\n\t\t\t\tif ( version === '1.5.0' ) {\n\n\t\t\t\t\timageNode += `<init_from><ref>${ options.textureDirectory }${ name }.${ ext }</ref></init_from>`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// version image node 1.4.1\n\t\t\t\t\timageNode += `<init_from>${ options.textureDirectory }${ name }.${ ext }</init_from>`;\n\n\t\t\t\t}\n\n\t\t\t\timageNode += '</image>';\n\n\t\t\t\tlibraryImages.push( imageNode );\n\t\t\t\timageMap.set( tex, texid );\n\t\t\t\ttextures.push( {\n\t\t\t\t\tdirectory: options.textureDirectory,\n\t\t\t\t\tname,\n\t\t\t\t\text,\n\t\t\t\t\tdata: imageToData( tex.image, ext ),\n\t\t\t\t\toriginal: tex\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn texid;\n\n\t\t}\n\n\t\t// Process the given material into the material and effect libraries\n\t\t// Returns the material id\n\t\tfunction processMaterial( m ) {\n\n\t\t\tlet matid = materialMap.get( m );\n\n\t\t\tif ( matid == null ) {\n\n\t\t\t\tmatid = `Mat${ libraryEffects.length + 1 }`;\n\n\t\t\t\tlet type = 'phong';\n\n\t\t\t\tif ( m.isMeshLambertMaterial === true ) {\n\n\t\t\t\t\ttype = 'lambert';\n\n\t\t\t\t} else if ( m.isMeshBasicMaterial === true ) {\n\n\t\t\t\t\ttype = 'constant';\n\n\t\t\t\t\tif ( m.map !== null ) {\n\n\t\t\t\t\t\t// The Collada spec does not support diffuse texture maps with the\n\t\t\t\t\t\t// constant shader type.\n\t\t\t\t\t\t// mrdoob/three.js#15469\n\t\t\t\t\t\tconsole.warn( 'ColladaExporter: Texture maps not supported with MeshBasicMaterial.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst emissive = m.emissive ? m.emissive : new Color( 0, 0, 0 );\n\t\t\t\tconst diffuse = m.color ? m.color : new Color( 0, 0, 0 );\n\t\t\t\tconst specular = m.specular ? m.specular : new Color( 1, 1, 1 );\n\t\t\t\tconst shininess = m.shininess || 0;\n\t\t\t\tconst reflectivity = m.reflectivity || 0;\n\n\t\t\t\t// Do not export and alpha map for the reasons mentioned in issue (#13792)\n\t\t\t\t// in three.js alpha maps are black and white, but collada expects the alpha\n\t\t\t\t// channel to specify the transparency\n\t\t\t\tlet transparencyNode = '';\n\t\t\t\tif ( m.transparent === true ) {\n\n\t\t\t\t\ttransparencyNode +=\n\t\t\t\t\t\t'<transparent>' +\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t'<texture texture=\"diffuse-sampler\"></texture>' :\n\t\t\t\t\t\t\t\t'<float>1</float>'\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t'</transparent>';\n\n\t\t\t\t\tif ( m.opacity < 1 ) {\n\n\t\t\t\t\t\ttransparencyNode += `<transparency><float>${ m.opacity }</float></transparency>`;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst techniqueNode = `<technique sid=\"common\"><${ type }>` +\n\n\t\t\t\t\t'<emission>' +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t'<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t`<color sid=\"emission\">${ emissive.r } ${ emissive.g } ${ emissive.b } 1</color>`\n\t\t\t\t\t) +\n\n\t\t\t\t\t'</emission>' +\n\n\t\t\t\t\t(\n\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t'<diffuse>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t'<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t`<color sid=\"diffuse\">${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color>`\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t'</diffuse>'\n\t\t\t\t\t\t\t: ''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t'<bump>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t'</bump>'\n\t\t\t\t\t\t\t: ''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\ttype === 'phong' ?\n\t\t\t\t\t\t\t`<specular><color sid=\"specular\">${ specular.r } ${ specular.g } ${ specular.b } 1</color></specular>` +\n\n\t\t\t\t\t\t'<shininess>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t\t'<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t`<float sid=\"shininess\">${ shininess }</float>`\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</shininess>'\n\t\t\t\t\t\t\t: ''\n\t\t\t\t\t) +\n\n\t\t\t\t\t`<reflective><color>${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color></reflective>` +\n\n\t\t\t\t\t`<reflectivity><float>${ reflectivity }</float></reflectivity>` +\n\n\t\t\t\t\ttransparencyNode +\n\n\t\t\t\t\t`</${ type }></technique>`;\n\n\t\t\t\tconst effectnode =\n\t\t\t\t\t`<effect id=\"${ matid }-effect\">` +\n\t\t\t\t\t'<profile_COMMON>' +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t'<newparam sid=\"diffuse-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.map ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t'<newparam sid=\"specular-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.specularMap ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t'<newparam sid=\"emissive-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.emissiveMap ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.normalMap ?\n\t\t\t\t\t\t\t'<newparam sid=\"bump-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.normalMap ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\ttechniqueNode +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.side === DoubleSide ?\n\t\t\t\t\t\t\t'<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t'</profile_COMMON>' +\n\n\t\t\t\t\t'</effect>';\n\n\t\t\t\tconst materialName = m.name ? ` name=\"${ m.name }\"` : '';\n\t\t\t\tconst materialNode = `<material id=\"${ matid }\"${ materialName }><instance_effect url=\"#${ matid }-effect\" /></material>`;\n\n\t\t\t\tlibraryMaterials.push( materialNode );\n\t\t\t\tlibraryEffects.push( effectnode );\n\t\t\t\tmaterialMap.set( m, matid );\n\n\t\t\t}\n\n\t\t\treturn matid;\n\n\t\t}\n\n\t\t// Recursively process the object into a scene\n\t\tfunction processObject( o ) {\n\n\t\t\tlet node = `<node name=\"${ o.name }\">`;\n\n\t\t\tnode += getTransform( o );\n\n\t\t\tif ( o.isMesh === true && o.geometry !== null ) {\n\n\t\t\t\t// function returns the id associated with the mesh and a \"BufferGeometry\" version\n\t\t\t\t// of the geometry in case it's not a geometry.\n\t\t\t\tconst geomInfo = processGeometry( o.geometry );\n\t\t\t\tconst meshid = geomInfo.meshid;\n\t\t\t\tconst geometry = geomInfo.bufferGeometry;\n\n\t\t\t\t// ids of the materials to bind to the geometry\n\t\t\t\tlet matids = null;\n\t\t\t\tlet matidsArray;\n\n\t\t\t\t// get a list of materials to bind to the sub groups of the geometry.\n\t\t\t\t// If the amount of subgroups is greater than the materials, than reuse\n\t\t\t\t// the materials.\n\t\t\t\tconst mat = o.material || new MeshBasicMaterial();\n\t\t\t\tconst materials = Array.isArray( mat ) ? mat : [ mat ];\n\n\t\t\t\tif ( geometry.groups.length > materials.length ) {\n\n\t\t\t\t\tmatidsArray = new Array( geometry.groups.length );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmatidsArray = new Array( materials.length );\n\n\t\t\t\t}\n\n\t\t\t\tmatids = matidsArray.fill().map( ( v, i ) => processMaterial( materials[ i % materials.length ] ) );\n\n\t\t\t\tnode +=\n\t\t\t\t\t`<instance_geometry url=\"#${ meshid }\">` +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tmatids != null ?\n\t\t\t\t\t\t\t'<bind_material><technique_common>' +\n\t\t\t\t\t\t\tmatids.map( ( id, i ) =>\n\n\t\t\t\t\t\t\t\t`<instance_material symbol=\"MESH_MATERIAL_${ i }\" target=\"#${ id }\" >` +\n\n\t\t\t\t\t\t\t\t'<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" />' +\n\n\t\t\t\t\t\t\t\t'</instance_material>'\n\t\t\t\t\t\t\t).join( '' ) +\n\t\t\t\t\t\t\t'</technique_common></bind_material>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t'</instance_geometry>';\n\n\t\t\t}\n\n\t\t\to.children.forEach( c => node += processObject( c ) );\n\n\t\t\tnode += '</node>';\n\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst geometryInfo = new WeakMap();\n\t\tconst materialMap = new WeakMap();\n\t\tconst imageMap = new WeakMap();\n\t\tconst textures = [];\n\n\t\tconst libraryImages = [];\n\t\tconst libraryGeometries = [];\n\t\tconst libraryEffects = [];\n\t\tconst libraryMaterials = [];\n\t\tconst libraryVisualScenes = processObject( object );\n\n\t\tconst specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n\t\tlet dae =\n\t\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>' +\n\t\t\t`<COLLADA xmlns=\"${ specLink }\" version=\"${ version }\">` +\n\t\t\t'<asset>' +\n\t\t\t(\n\t\t\t\t'<contributor>' +\n\t\t\t\t'<authoring_tool>three.js Collada Exporter</authoring_tool>' +\n\t\t\t\t( options.author !== null ? `<author>${ options.author }</author>` : '' ) +\n\t\t\t\t'</contributor>' +\n\t\t\t\t`<created>${ ( new Date() ).toISOString() }</created>` +\n\t\t\t\t`<modified>${ ( new Date() ).toISOString() }</modified>` +\n\t\t\t\t'<up_axis>Y_UP</up_axis>'\n\t\t\t) +\n\t\t\t'</asset>';\n\n\t\tdae += `<library_images>${ libraryImages.join( '' ) }</library_images>`;\n\n\t\tdae += `<library_effects>${ libraryEffects.join( '' ) }</library_effects>`;\n\n\t\tdae += `<library_materials>${ libraryMaterials.join( '' ) }</library_materials>`;\n\n\t\tdae += `<library_geometries>${ libraryGeometries.join( '' ) }</library_geometries>`;\n\n\t\tdae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${ libraryVisualScenes }</visual_scene></library_visual_scenes>`;\n\n\t\tdae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n\n\t\tdae += '</COLLADA>';\n\n\t\tconst res = {\n\t\t\tdata: format( dae ),\n\t\t\ttextures\n\t\t};\n\n\t\tif ( typeof onDone === 'function' ) {\n\n\t\t\trequestAnimationFrame( () => onDone( res ) );\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n\n}\n\n\nexport { ColladaExporter };\n"],
  "mappings": "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",
  "names": ["res"]
}
